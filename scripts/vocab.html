<!DOCTYPE html>
<title>Vocab Viewer</title>
<meta charset="utf-8">
<style>

body {
  margin: 0; padding: 0;
}

.node > ellipse {
  fill-opacity: .9;
  stroke-width: 1.5px;
  stroke: #fff;
}
.base.node > ellipse {
  stroke: #000;
}

.node > text {
  color: #000;
  text-anchor: middle;
}

.link {
  fill: none;
  stroke: #999;
  stroke-width: 2;
  stroke-opacity: .6;
}

svg {
  position: absolute;
  width: 100vw;
  height: 100vh;
}

</style>
<body>
<script src="d3.v3.min.js"></script>
<script>

var force = d3.layout.force()
    .charge(function (d) {
      if (d.link)
        return -20
      return -(200 + 100 * d.children.length + 20 * (d.siblingCount || 0))
    })
    .linkDistance(20)
    .linkStrength(0.1)
    .gravity(0.1)

var animated = true

var color = d3.scale.category20()

var svg = d3.select("body").append("svg")
    .attr("pointer-events", "all")

function resize() {
  var el = svg[0][0], width = el.clientWidth, height = el.clientHeight
  force.size([width, height])
}
resize()
window.addEventListener("onresize", resize)


svg.append("defs").selectAll("marker")
    .data(["arrow"])
  .enter().append("marker")
    .attr("id", String)
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 30).attr("refY", 0)
    .attr("markerWidth", 10).attr("markerHeight", 5)
    .attr("orient", "auto")
    .append("path")
    .attr("d", "M0,-5L10,0L0,5");


function viewData(source) {

  var view = svg.append("g")
      .call(d3.behavior.zoom().on("zoom", zoomRedraw))
      .append("g")

  function zoomRedraw() {
    if (animated)
      return
    var evt = d3.event
    view.attr("transform", "translate("+ evt.translate +") scale("+ evt.scale +")")
  }

  var nodeIndex = {}
  source.nodes.forEach(function (node) {
    nodeIndex[node.name] = node
  })

  var nodes = source.nodes.slice(),
      links = [],
      bilinks = []

  source.nodes.forEach(function (node) {
    if (!node.children)
      return
    node.children.forEach(function (id) {
      var child = nodeIndex[id]
      child.parent = node
      child.siblingCount = (child.siblingCount || 0) + node.children.length
      var im = {link: true}
      nodes.push(im)
      links.push({source: child, target: im}, {source: im, target: node})
      bilinks.push([child, im, node])
    })
  })

  var roots = source.nodes.filter(function (node) { return !node.parent })
  var rootBase = roots.length === 1? roots[0] : null

  function setGroupName(groupName, node) {
    node = (typeof node === 'object')? node : nodeIndex[node]
    node.isBase = rootBase? node.parent === rootBase : !node.parent
    groupName = groupName || (node.isBase? node.name : null)
    if (!groupName) {
      return
    }
    node.groupName = groupName
    if (node.children) {
      node.children.forEach(setGroupName.bind(this, groupName))
    }
  }
  source.nodes.forEach(setGroupName.bind(this, null))

  force
      .nodes(nodes)
      .links(links)

  var link = view.selectAll(".link")
      .data(bilinks)
      .enter().append("path")
      .attr("class", "link")

  var node = view.selectAll(".node")
      .data(source.nodes)
      .enter().append("g")
      .attr("class", function (d) { return d.isBase? "base node" : "node" })
      .on("dblclick", function () {
        d3.event.stopPropagation()
        if (!animated) {
          node.call(force.drag)
          force.start()
        } else {
          force.stop()
          node.on("mousedown.drag", null)
        }
        animated = !animated
      }, true)
  if (animated) {
      node.call(force.drag)
  }

  node.append("title")
      .text(function(d) { return d.isBase? d.name : d.name +" < "+ d.groupName; })

  node.append("ellipse")
      .attr("rx", 32).attr("ry", 16)
      .style("fill", function(d) { return color(d.groupName); })

  node.append("text")
      .attr("dy", ".31em")
      .text(function(d) { return d.name; })

  force.on("tick", function() {
    link.attr("d", function(d) {
          return "M" + d[0].x + "," + d[0].y
          + "S" + d[1].x + "," + d[1].y
          + " " + d[2].x + "," + d[2].y
        })
        .attr("marker-end", "url(#arrow)")

    node.attr('transform', function (d) { return "translate("+ d.x +","+ d.y +")" })
  })

  force.start()
  if (!animated) {
    var n = 80; // depends on graph complexity..
    for (var i = n * n; i > 0; --i) force.tick()
    force.stop()
  }

}


function handleLocation() {
  var ref = document.location.hash.substring(1)
  d3.select("svg").select("g").remove()
  if (ref) {
    d3.json(ref, function (err, data) { viewData(data) })
  }
}

window.addEventListener("hashchange", handleLocation)

handleLocation()

</script>
